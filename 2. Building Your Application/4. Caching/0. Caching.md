源地址: https://nextjs.org/docs/app/building-your-application/caching

# Caching in Next.js

Next.js 通过缓存渲染工作和数据请求来提升你的应用性能. 本页将深入介绍 Next.js 缓存机制, 可用于配置这些机制的 API 以及它们之间的交互.

> **请注意**: 本页可帮助您了解 Next.js 在表层下的工作原理, 不是使用 Next.js 提高工作效率的必备知识. Next.js 的大部分缓存启动都是由 API 使用情况决定的, 默认情况下不需要进行配置或少量配置即可获得最佳性能.

---

## Overview (总览)

以下是不同缓存机制及其用途的概述:

| Mechanism(机制)                                                                                                    | What                | Where  | Purpose                    | Duration                  |
| ------------------------------------------------------------------------------------------------------------------ | ------------------- | ------ | -------------------------- | ------------------------- |
| [Request memoization(请求记忆)](https://nextjs.org/docs/app/building-your-application/caching#request-memoization) | 函数的返回值        | 服务端 | 在 React 组件树中重用数据  | 每一次请求的生命周期      |
| [Data Cache(数据缓存)](https://nextjs.org/docs/app/building-your-application/caching#data-cache)                   | 数据                | 服务端 | 跨用户请求和部署的存储数据 | 持久的（可重新验证）      |
| [Full Route Cache(完整路由缓存)](https://nextjs.org/docs/app/building-your-application/caching#full-route-cache)   | HTML 和 RSC Payload | 服务端 | 减少渲染时间并提升性能     | 持久的（可重新验证）      |
| [Router Cache(路由缓存)](https://nextjs.org/docs/app/building-your-application/caching#router-cache)               | RSC Payload         | 客户端 | 减少导航时的服务端请求     | 用户 Session 或基于时间的 |

默认情况下, Next.js 会尽可能的进行缓存以便提高性能和减少开销. 这意味着路由会被静态渲染, 数据请求会被缓存, 除非你选择不使用它们. 下图显示了默认的缓存行为: 当在构建时静态渲染路由时, 和当首次访问静态路由时.

![overview_1](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fcaching-overview.png&w=1920&q=75&dpl=dpl_HLrzm1iszLgPFzNAQ3hHHL5Lhsu3)

缓存行为的变化取决于路由是静态渲染还是动态渲染, 数据是已缓存的还是未缓存的, 以及请求是首次访问的还是后续导航的. 根据使用情况, 你可以为单个路由和数据请求配置缓存行为.

---

## Request Memoization (请求记忆)

React 扩展了 [`fetch` API](https://nextjs.org/docs/app/building-your-application/caching#fetch)来对具有相同 URL 和选项的请求进行自动记录. 这意味着你可以在 React 组件树中的多个位置调用获取 `fetch` 函数来获取相同的数据, 最终只会执行一次.

![request_memoization_1](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fdeduplicated-fetch-requests.png&w=1920&q=75&dpl=dpl_HLrzm1iszLgPFzNAQ3hHHL5Lhsu3)

比如, 如果你在一个路由的 Layout(布局), Page(页面), 等多个组件中需要使用相同数据, 你不需要在组件树的顶层获取数据, 然后将数据作为属性传递给这些子组件. 相反的, 你可以在需要的组件中 `fetch` 数据, 不必担心在网络中对相同数据进行多次请求会影响性能.

app/example.tsx:

```typescript
async function getItem() {
  // The `fetch` function is automatically memoized and the result
  // is cached
  const res = await fetch("https://.../item/1");
  return res.json();
}

// This function is called twice, but only executed the first time
const item = await getItem(); // cache MISS

// The second call could be anywhere in your route
const item = await getItem(); // cache HIT
```

#### How Request Memoization Works (请求记忆的工作原理)

![how_request_Memoization_works](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Frequest-memoization.png&w=1920&q=75&dpl=dpl_HLrzm1iszLgPFzNAQ3hHHL5Lhsu3)

- 在渲染路由时, 第一次调用特定请求时, 其结果不会在内存中, 所以缓存 `MISS`.
- 因此, 该请求函数将被执行从外部源获取数据, 随后数据将被存储在内存中.
- 在同一渲染过程中, 对该请求函数的后续调用将会 `HIT(命中)` 缓存, 数据将从内存返回, 而不会执行函数.
- 一旦路由渲染完成, 渲染过程结束, 内存将被 "重置", 所有请求记忆的条目将被清除.

> **请注意**:
>
> - 请求记忆是 React 的一项功能, 而不是 Next.js 的一项功能. 在这里包含它是为了展示它是如何与其他缓存机制交互的.
> - 请求记忆只能用于 `fetch` 请求中的 `GET` 方法.
> - 请求记忆只能用于 React 组件树, 这意味着:
>   - 它可以作用于 `generateMetadata`, `generateStaticParams`, Layouts(布局), Pages(页面)和其他服务端组件内的 `fetch` 请求
>   - 它不会作用于 Route Handlers(路由处理器), 因为它们并不是 React 组件树的一部分.
> - 对于无法使用 `fetch` 的情况(例如某些数据库客户端, CMS 客户端或 GraphQL 客户端), 可以使用 [React `cache` function(React 缓存函数)](https://nextjs.org/docs/app/building-your-application/caching#react-cache-function) 对函数进行记忆.

### Duration (持续时间)

缓存将在服务器请求的生命周期内一直持续, 直到 React 组件树完成渲染.

### Revalidating (重新验证)

由于请求记忆不会在不同的服务器请求间共享, 而且只会在渲染过程中使用, 因此无需重新验证.

### Opting out (退出)

要退出 `fetch` 请求中的记忆, 你可以向请求传递 AbortController 信号.

app/example.js:

```typescript
const { signal } = new AbortController();
fetch(url, { signal });
```

---

## Data Cache (数据缓存)

Next.js 有一个内置的数据缓存(Data Cache), 它可以对即将到来的请求和部署时进行持久化. 之所以能做到这一点, 是因为 Next.js 扩展了原生的 `fetch` API, 允许服务器上的每个请求设置自己的缓存.

> **请注意**: 在浏览器中, `fetch` 的 `cache` 缓存选项表示请求将如何与浏览器的 HTTP 缓存交互, 而在 Next.js 中, `cache` 选项表示服务器请求将如何与服务器的 Data Cache(数据缓存)进行交互.

#### How the Data Cache Works (数据缓存的工作原理)

<!-- TODO: deployment应该怎么理解? -->

![how_the_data_cache_works_1](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fdata-cache.png&w=1920&q=75&dpl=dpl_HLrzm1iszLgPFzNAQ3hHHL5Lhsu3)

- 在渲染时, 一个 `fetch` 请求被第一次发送给服务器, Next.js 将会检查 Data Cache(数据缓存) 中是否有缓存的返回.
- 如果找到了返回, Next.js 会立即返回并 [memoized(记忆)](https://nextjs.org/docs/app/building-your-application/caching#request-memoization)
- 如果找不到, 请求将会被发送到数据源, 结果将会被存储进 Data Cache(数据缓存) 中并被记忆.
- 对于不使用缓存的数据(比如: `{cache: 'no-store'}`), 结果将永远从数据源获取并被记忆.
- 无论数据是需要缓存的还是不需要, 请求都会被记忆, 以避免在 React 渲染传递过程中对相同数据进行重复请求.

> **Data Cache(数据缓存) 和 Request Memoization(请求记忆)的区别**
>
> 虽然这两种缓存机制都是通过重复使用缓存数据来提高性能, 但 Data Cache(数据缓存) 是在为即将到来的请求和部署时持久的, 而 Request Memoization(请求记忆) 只在请求的生命周期内有效.
>
> 通过记忆, 我们可以减少同一渲染过程中从服务器渲染到数据缓存服务器(如 CDN 或边缘网络)或数据源(如数据库或内容管理系统)之间必须跨越网络边界的重复请求数量. 有了 Data Cache(数据缓存), 我们就能减少对原始数据源的请求次数.

### Duration (持续时间)

除非你重新验证或选择退出, 否则数据缓存会对即将到来的请求和部署过程中持续存在.

### Revalidating (重新验证)

缓存的数据会在下面两种方式下被重新验证:

- , revalidation(基于时间的重新验证): 在一定时间后自动重新验证数据. 这对于变化不频繁, 实时性要求不高的数据非常有用.
- On-demand revalidation(基于需求的重新验证): 基于事件(像表单提交)时, 手动重新验证数据. 按需重新验证可以使用基于标签或路径的方法来一次性重新验证一组数据. 当你想确保尽快显示最新数据时(例如, 当无 head 的内容管理系统的内容更新时), 这种方法非常有用.

#### Time-based Revalidation (基于时间的重新验证)

为了间隔性的重新验证数据, 你可以在 `fetch` 中使用 `next.revalidate` 选项来设置缓存资源的生命周期(通过秒数设置).

```typescript
// Revalidate at most every hour
fetch("https://...", { next: { revalidate: 3600 } });
```

另外, 如果要在一个路由段中重新验证所有的 `fetch` 请求, 你可以使用 [Segment Config Options(段配置选项)](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config).

##### How Time-based Revalidation Works(基于时间的重新验证的工作原理)

![how_time-based_revalidation_works](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Ftime-based-revalidation.png&w=1920&q=75&dpl=dpl_HLrzm1iszLgPFzNAQ3hHHL5Lhsu3)

- 首次调用带有 `revalidate` 的 `fetch` 请求时, 数据将从外部数据源获取并存储在 Data Cache(数据缓存中).
- 在指定时限(如 60 秒)内, 对该请求的任何调用都将返回缓存数据.
- 在指定实现后, 下一次请求仍将返回缓存数据(现在是过期数据).
  - Next.js 会在后台触发数据的重新验证.
  - 一旦成功获取数据, Next.js 就会使用新数据更新数据缓存.
  - 如果后台重新验证失败, 之前的数据将保持不变.

这与 [stale-while-revalidate(重新验证时的陈旧数据)](https://web.dev/stale-while-revalidate/) 行为类似.

#### On-demand Revalidation (基于需求的重新验证)

数据可根据路径(`revalidatePath`)或缓存标签(`revalidateTag`)按需重新验证.

##### How On-demand Revalidation Works(基于需求的重新验证的工作原理)

![how_on-demand_revalidation_works](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fon-demand-revalidation.png&w=1920&q=75&dpl=dpl_HLrzm1iszLgPFzNAQ3hHHL5Lhsu3)

- 首次调用 `fetch` 请求时, 数据将从外部数据源获取并存储在 Data Cache(数据缓存)中.
- 当一个按需重新验证被触发时, 缓存中的相应缓存条目将被清除.
  - 这与基于时间的重新验证不同, 后者将陈旧数据保留在缓存中, 直到获取到新数据.
- 下一次请求时, 将出现缓存 `MISS`, 数据将从外部数据源重新获取并存储到数据缓存中.

### Opting out (退出)

对于单个数据获取, 可以通过将 [`cache`](https://nextjs.org/docs/app/building-your-application/caching#fetch-optionscache) 选项设置为 `no-cache`来选择退出缓存. 这意味着只要调用 `fetch`, 就会从数据源获取数据.

```typescript
// Opt out of caching for an individual `fetch` request
fetch(`https://...`, { cache: "no-store" });
```

或者, 也可以使用[Route Segment Config(路由段配置)](https://nextjs.org/docs/app/building-your-application/caching#segment-config-options) 来选择退出指定路由段的缓存. 这将影响路由段中的所有数据请求, 包括第三方库.

```typescript
// Opt out of caching for all data requests in the route segment
export const dynamic = "force-dynamic";
```

> **Vercel Data Cache (Vercel 的数据缓存)**
>
> 如果你的 Next.js 应用程序是部署在 Vercel 上, 我们建议你阅读 [Vercel Data Cache(Vercel 的数据缓存)](https://vercel.com/docs/infrastructure/data-cache) 文档来帮助你更好了解 Vercel 的相关功能.

---

## Full Route Cache (完整路由缓存)

> **相关术语**:
>
> 你可能会看到 **Automatic Static Optimization(自动静态优化)**, **Static Site Generation(静态网站生成)** 或 **Static Rendering(静态渲染)** 等术语被交替使用, 它们用来指在构建时渲染和缓存应用程序路由的过程.

Next.js 会在构建时自动渲染和缓存路由. 这是一种优化, 为路由进行缓存, 而不是每次请求后在服务器上渲染, 从而加快页面加载速度.

要了解完整路由缓存的工作原理, 可以先看看 React 是如何处理渲染的, 以及 Next.js 是如何将结果缓存的:

### 1. React Rendering on the Server (React 在服务器渲染)

在服务器上, Next.js 使用 React 的 API 来编排渲染. 渲染工作被分成若干小块: 按单个路由段和 Suspense Boundaries(悬挂边界)划分.

每一块都会通过两步被渲染:

1. React 会将服务端组件渲染成一种特殊的数据格式, 并针对流式传输进行了优化, 这种格式被称为 **React Server Component Payload**.
2. Next.js 使用 React Server Component Payload 和客户端组件 JavaScript 命令在服务器上渲染 HTML.

这意味着我们不必等待所有内容都渲染完毕后再缓存或发送返回. 相反, 我们可以持续以流式方式发送响应指导工作全部完成.

> **什么是 React Server Component Payload?**
>
> RSC Payload 是被渲染的 React 服务端组件树的紧凑二进制表示. 客户端上的 React 会使用它来更新浏览器的 DOM. RSC Payload 包含:
>
> - 服务器组件渲染的结果
> - 客户端组件渲染位置的占位符和 JavaScript 文件的引用
> - 从服务端组件传递到客户端组件的任何属性
>
> 了解更多, 请查看 [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components) 文档.

### 2. Next.js Caching on the Server(Full Route Cache)

![next.js_caching_on_the_server_1](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Ffull-route-cache.png&w=1920&q=75&dpl=dpl_HLrzm1iszLgPFzNAQ3hHHL5Lhsu3)

Next.js 的默认行为是在服务器上缓存路由的渲染结果(React Server Component Payload 和 HTML). 这用于在构建时或重新验证时静态渲染的路由.

### 3. React Hydration and Reconciliation on the Client (在客户端进行水合与协调)

请求时, 在客户端:

1. 一个 HTML 被用于立即显示客户端和服务端组件的非交互式初始预览.
2. React Server Components Payload 用于协调客户端和渲染的服务端组件树, 并更新 DOM.
3. JavaScript 指令用于将客户端组件 [hydrate(水合化)](https://react.dev/reference/react-dom/client/hydrateRoot), 使应用程序具有交互性.

### 4. Next.js Caching on the Client(Router Cache) (Next.js 客户端缓存(路由缓存))

The React Server Component Payload 被存储在客户端路由缓存(Router Cache)中, 这是一个单独的内存缓存, 按各个路由段分割. 路由缓存用于存储以前访问过的路由并预获取将要访问的路由, 从而改善导航体验.

### 5. Subsequent Navigations (后续导航)

在后续的导航或预获取过程中, Next.js 会检查 React Server Components Payload 是否存储在路由器缓存中. 如果是, 它将跳过向服务器发送新请求.

如果路由段不在缓存中, Next.js 将从服务器获取 React Server Components Payload, 并在客户端填充路由器缓存.

### Static and Dynamic Rendering

路由在构建时是否被缓存取决于它是静态渲染还是动态渲染. 静态路由默认为缓存, 而动态路由在请求时渲染, 不进行缓存.

此图显示了静态路由和动态路由在缓存和未缓存数据时的区别:

![static_and_dynamic_rendering](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fstatic-and-dynamic-routes.png&w=1920&q=75&dpl=dpl_HLrzm1iszLgPFzNAQ3hHHL5Lhsu3)

了解更多关于 [静态渲染和动态渲染](https://nextjs.org/docs/app/building-your-application/rendering/server-components#server-rendering-strategies).

### Duration (持续时间)

默认情况下, 完整路由缓存是持久的. 这意味这对于不同的用户请求将会使用同一个缓存结果.

### Invalidation (无效)

有两种方式可以使完整路由缓存无效化:

- [Revalidating Data(重新验证数据)](https://nextjs.org/docs/app/building-your-application/caching#revalidating), 通过在服务器上重新渲染组件并缓存新的渲染输出, 数据缓存的重新失效将反过来使完整路由缓存失效.
- 重新部署: 与 Data Cache 不类似(可以跨部署), 完整路由缓存将会在新部署时被清理.

### Opting out (退出)

你可以选择退出完整路由缓存, 换句话说, 为每一个即将到来的请求都动态渲染组件. 可以通过以下方式:

- 使用 [Dynamic Function(动态函数)](https://nextjs.org/docs/app/building-your-application/caching#dynamic-functions): 这将从完整路由缓存中选择路由, 并在请求时动态渲染. 注意, 此时 Data Cache(数据缓存) 仍然可用.
- 使用 `dynamic='force-dynamic'` 或者 `revalidate=0`路由段控制选项. 这将跳过完整路由缓存和 Data Cache(数据缓存). 这意味着每次向服务器发出请求时, 都会对组件进行渲染并获取数据. Router Cache(路由缓存)仍然适用, 因为它是客户端缓存.
- 选择退出 [Data Cache(数据缓存)](https://nextjs.org/docs/app/building-your-application/caching#data-cache): 如果路由有一个未缓存的 `fetch` 请求, 这将使该路由退出完整路由缓存. 每次传入请求时, 都会获取特定 `fetch` 请求的数据. 其他未选择退出缓存的 `fetch` 请求仍将在数据缓存中缓存. 这样就可以实现缓存与非缓存数据的混合.

---

## Router Cache (路由缓存)

### Duration

### Invalidation

### Opting out

---

## Cache Interactions

### Data Cache and Full Route Cache

### Data Cache and Client-side Router cache

---

## APIs

### <Link>

### router.prefetch

### router.refresh

### fetch

### fetch options.cache

### fetch options.next.revalidate

### fetch options.next.tags and revalidateTag

### revalidatePath

### Dynamic Functions

#### cookies

### Segment Config Options

### generateStaticParams

### React cache function
